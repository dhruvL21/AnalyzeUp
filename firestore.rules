/**
 * Core Philosophy: This ruleset enforces a strict multi-tenant security model.
 * All data is segregated by a 'tenantId'. A user's access to any resource
 * is primarily determined by their membership in a specific tenant, which is
 * defined in their user profile document.
 *
 * Data Structure: There are two top-level collections:
 * 1. /users/{userId}: Stores private user profiles. Crucially, each user
 *    document contains a `tenantId` field that links them to their organization.
 * 2. /tenants/{tenantId}: Contains tenant-specific data. All business entities
 *    like products, orders, and locations are stored in subcollections under
 *    a specific tenant document.
 *
 * Key Security Decisions:
 * - Tenant-Scoped Access: All access to data within `/tenants/{tenantId}` requires
 *   a lookup on the requesting user's profile (`/users/{request.auth.uid}`) to
 *   verify that their `tenantId` matches the `tenantId` of the resource being
 *   accessed.
 * - Private User Profiles: A user can only read and write their own document in
 *   the `/users` collection. Listing users is disabled to prevent user enumeration.
 * - No Custom Claims: Authorization relies entirely on data stored in Firestore
 *   (the user's role and tenantId in their user document), not on custom auth claims.
 *
 * Denormalization for Authorization: The `tenantId` is denormalized and stored on
 * every document within a tenant's subcollections (e.g., on a Product document).
 * This allows security rules to validate on creation that a document is being
 * placed in the correct tenant's data tree, and to enforce that this tenant link
 * cannot be changed on update. This avoids costly `get` calls on parent documents.
 *
 * Structural Segregation: The entire database is segregated by tenant at the root
 * level (`/tenants/{tenantId}`). This is a highly secure and performant pattern
 * for multi-tenancy, as queries are naturally confined within a tenant's data tree.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for document existence. Critical for safe update/delete ops.
     */
    function documentExists() {
      return resource != null;
    }

    /**
     * Retrieves the authenticated user's profile document data from the
     * `/users` collection. This is central to the multi-tenancy logic.
     */
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    /**
     * Returns true if the authenticated user belongs to the specified tenant.
     * This is the core authorization check for all tenant-scoped data.
     */
    function isUserOfTenant(tenantId) {
      return isSignedIn() && getUserData().tenantId == tenantId;
    }

    // --------------------------------------------------------------------
    // User Profile Rules
    // --------------------------------------------------------------------

    /**
     * @description Users can create, read, and write their own profile document,
     * but cannot see or list other users' profiles.
     * @path /users/{userId}
     * @allow A signed-in user (uid: 'user-abc') can (create) their own document at `/users/user-abc`.
     * @deny An anonymous user cannot (get) any user document.
     * @deny A signed-in user (uid: 'user-abc') cannot (get) another user's document at `/users/user-xyz`.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && documentExists() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && documentExists();
    }

    // --------------------------------------------------------------------
    // Tenant Rules
    // --------------------------------------------------------------------

    /**
     * @description A tenant's main document can be read and modified by any
     * authenticated user belonging to that tenant.
     * @path /tenants/{tenantId}
     * @allow A user whose profile has `tenantId: 'tenant-123'` can (get) the document at `/tenants/tenant-123`.
     * @deny A user whose profile has `tenantId: 'tenant-456'` cannot (update) the document at `/tenants/tenant-123`.
     * @principle Enforces tenant-level data segregation. Access is granted based on the user's tenant membership.
     */
    match /tenants/{tenantId} {
      allow get, list: if isUserOfTenant(tenantId);
      allow create: if isUserOfTenant(tenantId); // Assumes tenant is created by an admin/backend, then users are added.
      allow update: if isUserOfTenant(tenantId) && documentExists();
      allow delete: if isUserOfTenant(tenantId) && documentExists();
    }

    /**
     * @description Secures all tenant subcollections (products, locations, orders, etc.)
     * and their nested documents (like lineItems).
     * @path /tenants/{tenantId}/{path=**}
     * @allow A user in tenant 'acme' can (create) a product under `/tenants/acme/products/{productId}`.
     * @deny A user in tenant 'widgets-inc' cannot (list) sales orders under `/tenants/acme/salesOrders`.
     * @principle Uses a recursive wildcard to apply a consistent tenant-ownership security model to all business data.
     */
    match /tenants/{tenantId}/{path=**} {
      allow get, list: if isUserOfTenant(tenantId);
      allow create: if isUserOfTenant(tenantId) && request.resource.data.tenantId == tenantId;
      allow update: if isUserOfTenant(tenantId) && documentExists() && request.resource.data.tenantId == resource.data.tenantId;
      allow delete: if isUserOfTenant(tenantId) && documentExists();
    }
  }
}