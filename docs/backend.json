{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user account within the system.  Does NOT store authentication secrets (passwords) - assume an external auth system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "tenantId": {
          "type": "string",
          "description": "Reference to Tenant. (Relationship: Tenant 1:N User).  Indicates which tenant/workspace this user belongs to."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        },
        "firstName": {
          "type": "string",
          "description": "The user's first name."
        },
        "lastName": {
          "type": "string",
          "description": "The user's last name."
        },
        "role": {
          "type": "string",
          "description": "The user's role within the tenant (e.g., Owner, Manager, Staff).",
          "format": "string"
        },
        "createdAt": {
          "type": "string",
          "description": "The date and time when the user was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "The date and time when the user was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "tenantId",
        "email",
        "firstName",
        "lastName",
        "role",
        "createdAt",
        "updatedAt"
      ]
    },
    "Tenant": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Tenant",
      "type": "object",
      "description": "Represents a tenant or workspace in the multi-tenant SaaS application (e.g., a startup's account).",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Tenant entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the tenant (e.g., startup's name)."
        },
        "domain": {
          "type": "string",
          "description": "The tenant's domain (optional)."
        },
        "createdAt": {
          "type": "string",
          "description": "The date and time when the tenant was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "The date and time when the tenant was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "name",
        "createdAt",
        "updatedAt"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/tenants/{tenantId}",
        "definition": {
          "entityName": "Tenant",
          "schema": {
            "$ref": "#/backend/entities/Tenant"
          },
          "description": "Represents a tenant or workspace in the application.",
          "params": [
            {
              "name": "tenantId",
              "description": "The unique identifier for the tenant."
            }
          ]
        }
      },
      {
        "path": "/tenants/{tenantId}/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Represents a user account within a specific tenant. Includes denormalized 'tenantId' for authorization independence.",
          "params": [
            {
              "name": "tenantId",
              "description": "The unique identifier for the tenant."
            },
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      }
    ],
    "reasoning": "This Firestore structure is designed to support Upstart Inventory, a multi-tenant SaaS platform for startups. The primary goal is to provide a secure, scalable, and easily maintainable data structure that aligns with Firestore's best practices, particularly emphasizing authorization independence. Here's a breakdown of the design and its adherence to the core principles:\n\n**1. Authorization Independence (CRITICAL):**\n   - **Tenants:** Each startup operates within its own tenant.  The `tenantId` is denormalized into every `User` document. This allows security rules to validate that a user belongs to the correct tenant without needing to perform expensive `get()` operations on the `Tenant` document itself.\n   - **Users:** User documents are stored within a tenant-specific subcollection (`/tenants/{tenantId}/users/{userId}`).  Access control is enforced based on the authenticated user's ID and the denormalized `tenantId`. This eliminates the need to check parent document attributes, such as ownership, during authorization checks.\n\n**2. Clarity of Intent (Debuggability):**\n   - The structure clearly reflects the relationships between tenants and users. The path `/tenants/{tenantId}/users/{userId}` expresses the 'tenant owns users' relationship. This makes it very clear how to implement the security rule.\n   - The use of descriptive field names (e.g., `tenantId`, `userId`) enhances readability and understanding of the data model.\n\n**3. DBAC (No Custom Claims):**\n   - The `User` document stores the `role` of the user. Security rules use this information, coupled with the user's ID and tenant ID, to authorize operations. No custom claims are needed.\n\n**4. QAPs (Rules are not Filters):**\n   - The structure enables secure `list` operations by isolating data within tenant-specific subcollections. A rule can allow listing users within a tenant based on the authenticated user's `tenantId`, preventing unauthorized access to other tenants' data.  The `tenantId` parameter allows this QAP to be met simply.\n\n**5. Invariants:**\n   - The structure supports data integrity by providing clear ownership. Each user belongs to exactly one tenant (defined by `tenantId` in `User`).\n   - Timestamps (`createdAt`, `updatedAt`) enforce invariants related to data creation and modification times. Although the structure does not automatically enforce timestamp correctness, these fields provide a mechanism to track and validate the data's history in server side code via firebase functions.\n\n**Design Strategy Mandates:**\n\n*   **A. Authorization Independence via Denormalization:** The `tenantId` is denormalized from the `Tenant` document into the `User` document. This allows security rules to avoid using `get()` calls to fetch the `Tenant`'s properties, making operations atomic and easier to debug.\n*   **B. Structural Segregation (Homogeneous Security Posture):** Tenants are separated into different collections. This provides a strong security boundary, ensuring data is isolated and that different tenants cannot interfere with each other. Also, User drafts and User public profiles would live in separate collections, as needed.\n*   **C. Access Modeling:** The structure uses path-based ownership (`/tenants/{tenantId}/users/{userId}`) to represent the tenant-user relationship.  This is the preferred pattern for private data owned by a tenant or user.\n*   **D. Data Clarity and Predictability:**  The schema includes explicit state modelling (through the `role` field in the `User` document) and predictable naming conventions."
  }
}